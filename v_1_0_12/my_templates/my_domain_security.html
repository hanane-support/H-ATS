{% extends "my_base.html" %}

{% block title %}도메인 및 보안 - H-ATS Admin{% endblock %}

{% block page_header %}도메인 및 보안 관리{% endblock %}

{% block content %}

<div class="card domain-security-card">
    <h2 class="card-title">도메인 및 보안 정보</h2>
    <p class="security-recommendation-text">
        <span class="security-text-span">
            HTTP 는 데이터를 암호화하지 않고 전송하지만, HTTPS 는 SSL/TLS 로 데이터를 암호화해 보안을 강화합니다.
            <br>HTTPS 보안을 적용하기 위해 도메인 등록을 권장합니다.
        </span>
    </p>
    <hr class="card-hr">

    <h3 class="section-header">서버 상태</h3>

    <div class="status-box">
        <div class="status-content">
            <p>
                <span class="status-label">IP :</span>
                <span class="status-value-ip" id="actualIpDisplay">IP 주소 확인 중...</span>
            </p>

            <p>
                <span class="status-label">도메인 :</span>
                <!-- 초기 로드 시 Caddy API 상태를 가져오기 위한 초기값으로 사용될 수 있습니다. -->
                <span class="status-value" id="currentDomainDisplay">{{ domain_name | default('없음') }}</span>
            </p>

            <p>
                <span class="status-label">보안 :</span>
                <span id="securityStatusDisplay"
                    class="{% if security_status == 'HTTPS' %}status-value-success{% else %}status-value-error{% endif %}">
                    {% if security_status == 'HTTPS' %}
                    적용 (HTTPS)
                    {% else %}
                    미적용 (HTTP)
                    {% endif %}
                </span>
            </p>
        </div>
    </div>

    <h3 class="section-header">도메인 관리</h3>

    <div>
        <input type="text" id="domain-input" placeholder="example.com (영문 도메인 권장)" class="domain-input"
            pattern="^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,63}$"
            title="유효한 도메인 형식 (예: example.com, sub.example.co.kr)">

        <div class="button-group">
            <button id="registerDomainButton" class="small-button accent-color-bg full-width-button">도메인 등록</button>

            <button id="releaseDomainButton" class="small-button delete-button full-width-button" disabled>도메인
                해제</button>
        </div>
    </div>
</div>

<div id="registerDomainModal" class="modal-overlay hidden-modal">
    <div class="modal-content">
        <h3 class="modal-header-danger">도메인 등록 확인</h3>
        <p class="modal-text">
            (<span id="modal-domain-display"></span>) 을 도메인으로 등록합니다. <br><br>
            <span class="modal-text-success">등록 후 SSL/TLS 보안 적용이 시작됩니다.</span>
        </p>
        <div class="modal-actions">
            <button id="confirmRegisterDomain" class="small-button accent-color-bg">
                등록
            </button>
            <button id="cancelRegisterDomain" class="small-button secondary-color-bg">
                취소
            </button>
        </div>
    </div>
</div>

<div id="releaseDomainModal" class="modal-overlay hidden-modal">
    <div class="modal-content">
        <h3 class="modal-header-danger">도메인 해제 확인</h3>
        <p class="modal-text">
            도메인을 해제하고 IP (HTTP) 로 사용합니다. <br>
        </p>
        <p class="modal-text-danger">
            보안이 취약해질 수 있습니다.
        </p>
        <div class="modal-actions">
            <button id="confirmReleaseDomain" class="small-button delete-button-confirm">
                해제
            </button>
            <button id="cancelReleaseDomain" class="small-button secondary-color-bg">
                취소
            </button>
        </div>
    </div>
</div>

<div id="messageModal" class="modal-overlay hidden-modal">
    <div class="modal-content">
        <h3 id="messageModalHeader" class="modal-header-danger"></h3>
        <p id="messageModalText" class="modal-text"></p>
        <div class="modal-actions">
            <button id="closeMessageModal" class="small-button secondary-color-bg">
                확인
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_head_styles %}
<style>
    :root {
        --text-color-light: #e0e0e0;
        --text-color-dark: #bdbdbd;
        --header-bg-dark: #2c2c2c;
        --sidebar-bg-dark: #212121;
        --border-color-dark: #444;
        --accent-color: #007bff;
        /* 파란색 계열 유지 */
    }

    .card {
        background-color: var(--header-bg-dark);
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        border: 1px solid var(--border-color-dark);
        max-width: 600px;
        /* 최대 너비 제한 */
        margin: 0 auto;
        /* 중앙 정렬 */
    }

    /* Modal Styling */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    .hidden-modal {
        display: none !important;
    }

    .modal-content {
        background-color: var(--header-bg-dark);
        padding: 25px;
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        border: 1px solid var(--border-color-dark);
        max-width: 400px;
        width: 90%;
        text-align: center;
    }

    /* Modal Headers */
    .modal-header-danger {
        color: var(--accent-color);
        font-size: 1.5em;
        margin-bottom: 30px;
        margin-top: 0;
    }

    .modal-header-success {
        color: #8BC34A;
        font-size: 1.5em;
        margin-bottom: 30px;
        margin-top: 0;
    }

    #releaseDomainModal .modal-header-danger {
        color: #ff4d4d;
    }

    .modal-text {
        color: var(--text-color-light);
        margin-bottom: 15px;
        line-height: 1.4;
        font-size: 1em;
    }

    .modal-text-success {
        color: #83ff52;
    }

    .modal-text-danger {
        color: #ff4d4d;
        margin-bottom: 25px;
        font-size: 1em;
    }

    .modal-actions {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 30px;
    }

    .card-title {
        color: var(--text-color-light);
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 1.5em;
    }

    .security-recommendation-text {
        color: var(--text-color-dark);
        margin-top: 5px;
        margin-bottom: 15px;
        line-height: 1.4;
    }

    .card-hr {
        border: 0;
        height: 1px;
        background-color: var(--border-color-dark);
        margin-top: 20px;
        margin-bottom: 30px;
    }

    .section-header {
        color: var(--text-color-light);
        margin-top: 35px;
        margin-bottom: 10px;
        font-size: 1.2em;
    }

    .status-box {
        margin-top: 0;
        padding: 20px;
        border: 1px solid var(--border-color-dark);
        border-radius: 8px;
        background-color: var(--sidebar-bg-dark);
    }

    .status-content p {
        margin: 12px 0;
        line-height: 1.2;
    }

    .status-label {
        color: var(--text-color-dark);
        display: inline-block;
        width: 80px;
    }

    .status-value {
        color: var(--text-color-light);
    }

    .status-value-ip {
        color: #FFEB3B;
        font-size: 1.1em;
    }

    /* 보안 상태 표시를 위한 스타일 */
    .status-value-pending {
        color: #FFC107;
        /* 노란색/주황색 계열 */
    }

    .status-value-success {
        color: #8BC34A;
        /* 녹색 */
    }

    .status-value-error {
        color: #EF5350;
        /* 빨간색 */
    }

    .domain-input {
        width: 100%;
        padding: 12px;
        margin-top: 0;
        margin-bottom: 25px;
        border: 1px solid #444;
        border-radius: 6px;
        background-color: var(--sidebar-bg-dark);
        color: var(--text-color-light);
        font-size: 1em;
        box-sizing: border-box;
    }

    .button-group {
        display: flex;
        gap: 10px;
        margin-top: 0px;
    }

    .small-button {
        padding: 10px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s, opacity 0.3s;
        color: var(--text-color-light);
        font-size: 1em;
        flex-grow: 1;
    }

    .small-button[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
    }

    .accent-color-bg {
        background-color: var(--accent-color);
    }

    .accent-color-bg:hover:not([disabled]) {
        background-color: #0056b3;
    }

    .secondary-color-bg {
        background-color: #6c757d;
        color: white;
    }

    .secondary-color-bg:hover:not([disabled]) {
        background-color: #5a6268;
    }

    .delete-button {
        background-color: #dc3545;
        color: white;
    }

    .delete-button:hover:not([disabled]) {
        background-color: #c82333;
    }

    .delete-button-confirm {
        background-color: #dc3545;
        color: white;
    }

    .delete-button-confirm:hover:not([disabled]) {
        background-color: #c82333;
    }

    .full-width-button {
        padding: 10px 20px;
        border-radius: 6px;
    }
</style>
{% endblock %}

{% block page_script %}
<script>
    // FastAPI 환경에서 사용될 Base URL을 정의합니다.
    const BASE_URL = '/admin/domain_security';

    // Caddy Admin API의 기본 URL
    const CADDY_ADMIN_ROUTES_URL = 'http://localhost:2019/config/apps/http/servers/srv0/routes';
    const FALLBACK_IP_URL = 'https://ifconfig.me/ip'; // 공인 IP 확인용 API

    let currentDomain = '';
    let publicIpAddress = ''; // 공인 IP를 저장할 변수

    document.addEventListener('DOMContentLoaded', () => {
        const registerButton = document.getElementById('registerDomainButton');
        const registerModal = document.getElementById('registerDomainModal');
        const confirmRegister = document.getElementById('confirmRegisterDomain');
        const cancelRegister = document.getElementById('cancelRegisterDomain');
        const releaseButton = document.getElementById('releaseDomainButton');
        const releaseModal = document.getElementById('releaseDomainModal');
        const confirmRelease = document.getElementById('confirmReleaseDomain');
        const cancelRelease = document.getElementById('cancelReleaseDomain');
        const domainInput = document.getElementById('domain-input');
        const modalDomainDisplay = document.getElementById('modal-domain-display');

        // 상태 표시 업데이트를 위한 요소
        const actualIpDisplay = document.getElementById('actualIpDisplay');
        const currentDomainDisplay = document.getElementById('currentDomainDisplay');
        const securityStatusDisplay = document.getElementById('securityStatusDisplay');

        // 커스텀 메시지 모달 요소
        const messageModal = document.getElementById('messageModal');
        const messageModalHeader = document.getElementById('messageModalHeader');
        const messageModalText = document.getElementById('messageModalText');
        const closeMessageModal = document.getElementById('closeMessageModal');

        // alert()를 대체하는 메시지 모달 표시 함수
        const showMessage = (header, text, isSuccess = true) => {
            messageModalHeader.textContent = header;
            messageModalText.innerHTML = text;

            messageModalHeader.classList.remove('modal-header-danger', 'modal-header-success');
            if (isSuccess) {
                messageModalHeader.classList.add('modal-header-success');
            } else {
                messageModalHeader.classList.add('modal-header-danger');
            }

            messageModal.classList.remove('hidden-modal');
        };

        // 모달 닫기 이벤트 리스너
        const handlePostAction = () => {
            messageModal.classList.add('hidden-modal');
            // '확인' 버튼을 누른 후에는 최종 상태를 다시 확인합니다.
            initializeStatus();
        };

        closeMessageModal.addEventListener('click', handlePostAction);

        // ----------------------------------------------------
        // 보안 상태 표시 업데이트 유틸리티
        // ----------------------------------------------------
        const updateSecurityStatusUI = (statusText, statusClass) => {
            securityStatusDisplay.textContent = statusText;
            securityStatusDisplay.classList.remove('status-value-success', 'status-value-error', 'status-value-pending');
            securityStatusDisplay.classList.add(statusClass);
        };

        // ----------------------------------------------------
        // Caddy Admin API를 활용하여 현재 설정 상태를 가져오는 함수
        // ----------------------------------------------------
        const initializeStatus = async () => {
            // 1. 공인 IP 주소 가져오기
            try {
                const ipResponse = await fetch(FALLBACK_IP_URL);
                if (!ipResponse.ok) throw new Error('IP API 응답 오류');

                const ipText = (await ipResponse.text()).trim();

                if (ipText && (ipText.match(/\./g) || ipText.match(/:/g))) {
                    publicIpAddress = ipText; // 전역 변수에 저장
                    actualIpDisplay.textContent = publicIpAddress;
                } else {
                    actualIpDisplay.textContent = 'IP 주소 형식 오류';
                    publicIpAddress = '';
                }
            } catch (error) {
                console.error("공인 IP 주소를 가져오는 중 오류 발생:", error);
                actualIpDisplay.innerHTML = 'IP 주소 확인 실패 (<a href="https://www.whatismyip.com/" target="_blank" style="color:#FFEB3B; text-decoration: underline;">외부에서 확인</a>)';
                publicIpAddress = '';
            }

            // 2. Caddyfile을 읽어와서 도메인 정보 파싱 (Caddy Admin API가 아닌 Caddyfile의 최종 상태를 기반으로 판단)
            // Caddy Admin API는 Caddyfile이 적용된 후에만 최신 정보를 주므로,
            // 등록 성공 후에는 UI를 Caddyfile의 예상 상태로 업데이트하고,
            // 새로고침 시에는 현재 Caddy Admin API의 상태를 읽어오는 것이 가장 정확합니다.

            // 여기서는 Caddy Admin API의 HTTP 서버에 어떤 라우트가 설정되어 있는지 확인합니다.
            let domainFromCaddy = '';

            try {
                // Caddyfile이 업데이트되고 Caddy가 재로드되었다면, 이 API는 새 설정을 반환해야 합니다.
                const caddyResponse = await fetch(CADDY_ADMIN_ROUTES_URL);

                if (caddyResponse.ok) {
                    const routes = await caddyResponse.json();

                    for (const route of routes) {
                        const hostMatches = route.match?.find(m => m.host);

                        if (hostMatches && hostMatches.host?.length > 0) {
                            const candidate = hostMatches.host[0];
                            // IP 주소(공인 IP)나 포트(:80)가 아닌, 점(.)을 포함하는 문자열을 도메인으로 간주
                            if (candidate !== publicIpAddress && !candidate.startsWith(':') && candidate.includes('.')) {
                                domainFromCaddy = candidate;
                                break;
                            }
                        }
                    }
                } else {
                    console.warn(`Caddy Admin API 응답 오류 (${caddyResponse.status}). 현재 상태 확인 불가.`);
                }
            } catch (error) {
                console.warn("Caddy Admin API 연결 실패. 현재 상태 확인 불가.", error);
            }

            // 3. UI에 최종 상태 반영
            currentDomain = domainFromCaddy;
            currentDomainDisplay.textContent = domainFromCaddy || '없음';
            domainInput.value = domainFromCaddy || ''; // <-- 도메인 입력 필드에 등록된 도메인 표시

            const statusText = domainFromCaddy ? '적용 (HTTPS)' : '미적용 (HTTP)';
            const statusClass = domainFromCaddy ? 'status-value-success' : 'status-value-error';
            updateSecurityStatusUI(statusText, statusClass);

            // 도메인이 등록되지 않은 경우 해제 버튼 비활성화
            releaseButton.disabled = !domainFromCaddy;
        };

        // 페이지 로드 시 상태 초기화 실행
        initializeStatus();


        // ----------------------------------------------------
        // 도메인 등록 로직
        // ----------------------------------------------------
        registerButton.addEventListener('click', () => {
            const domain = domainInput.value.trim();

            if (!domain) {
                showMessage("오류", "도메인을 먼저 입력해주세요.", false);
                return;
            }

            if (domainInput.checkValidity() === false) {
                showMessage("오류", "유효한 도메인 형식이 아닙니다.<br>예: example.com, sub.example.co.kr", false);
                return;
            }

            if (!publicIpAddress) {
                showMessage("오류", "공인 IP 주소를 확인할 수 없어 도메인 등록을 진행할 수 없습니다. IP 확인을 시도해주세요.", false);
                return;
            }

            modalDomainDisplay.textContent = domain;
            registerModal.classList.remove('hidden-modal');
        });

        cancelRegister.addEventListener('click', () => {
            registerModal.classList.add('hidden-modal');
        });

        confirmRegister.addEventListener('click', async () => {
            registerModal.classList.add('hidden-modal');
            const domain = domainInput.value.trim();
            const ip = publicIpAddress; // 전역 변수에서 IP 사용

            // 1. 상태를 '등록 요청 중'으로 업데이트
            updateSecurityStatusUI('등록 요청 중...', 'status-value-pending');

            try {
                // FastAPI의 도메인 등록 엔드포인트 호출 (도메인과 IP 주소를 모두 보냄)
                const response = await fetch(`${BASE_URL}/apply_security`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ domain: domain }) // IP 제거
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    // Caddyfile 업데이트 및 재로드 성공 후: 상태를 '인증서 발급 대기 중'으로 업데이트
                    // 클라이언트 측 상태 업데이트 (즉시 반영 - 성공했으므로 Caddyfile에 등록된 것으로 간주)
                    currentDomainDisplay.textContent = domain;
                    currentDomain = domain;
                    domainInput.value = domain;
                    releaseButton.disabled = false;

                    showMessage("등록 요청 성공", `✅ ${domain} 도메인이 등록되었고 Caddy가 재로드되었습니다.<br>인증서 발급이 완료되면 HTTPS가 적용됩니다.`, true);

                } else {
                    // 실패 시: 상태를 '오류 발생'으로 업데이트 후 원래 상태로 복구 시도
                    showMessage("등록 실패", `❌ 도메인 등록 중 오류가 발생했습니다.<br>${data.message || '서버 응답 오류'}`, false);
                    updateSecurityStatusUI('등록 실패 (HTTP 유지)', 'status-value-error');
                }
            } catch (error) {
                // 통신 오류 시: 상태를 '통신 오류'로 업데이트 후 원래 상태로 복구 시도
                showMessage("통신 오류", `❌ 서버와 통신 중 오류 발생: ${error.message}`, false);
                updateSecurityStatusUI('통신 오류 (HTTP 유지)', 'status-value-error');
            }
        });

        // ----------------------------------------------------
        // 도메인 해제 로직
        // ----------------------------------------------------
        releaseButton.addEventListener('click', () => {
            if (releaseButton.disabled || currentDomainDisplay.textContent.trim() === '없음') {
                showMessage("알림", "현재 등록된 도메인이 없어 해제가 불가능합니다.", false);
                return;
            }
            if (!publicIpAddress) {
                showMessage("오류", "공인 IP 주소를 확인할 수 없어 해제(IP 복구)를 진행할 수 없습니다.", false);
                return;
            }
            releaseModal.classList.remove('hidden-modal');
        });

        cancelRelease.addEventListener('click', () => {
            releaseModal.classList.add('hidden-modal');
        });

        confirmRelease.addEventListener('click', async () => {
            releaseModal.classList.add('hidden-modal');

            const domainForRelease = currentDomainDisplay.textContent.trim();
            const ip = publicIpAddress; // 전역 변수에서 IP 사용

            if (domainForRelease === '없음' || !domainForRelease) {
                showMessage("오류", "해제할 도메인 정보가 유효하지 않습니다.", false);
                return;
            }

            // 1. 상태를 '해제 요청 중'으로 업데이트
            updateSecurityStatusUI('해제 요청 중...', 'status-value-pending');

            try {
                // FastAPI의 도메인 해제 엔드포인트 호출
                const response = await fetch(`${BASE_URL}/release_security`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    // 해제 시 Caddyfile 복구를 위해 현재 도메인 이름을 보냄
                    body: JSON.stringify({ current_domain: domainForRelease })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    // 2. 상태를 '해제 완료'로 업데이트 (HTTP 복구)

                    // 클라이언트 측 상태 업데이트 (즉시 반영)
                    currentDomainDisplay.textContent = '없음';
                    currentDomain = '';
                    domainInput.value = '';
                    releaseButton.disabled = true;

                    showMessage("해제 완료", `✅ 도메인(${domainForRelease})이 해제되었으며,<br>IP (HTTP) 접근으로 변경되었습니다. Caddy 재로드 완료.`, true);

                } else {
                    // 실패 시: 상태를 '오류 발생'으로 업데이트 후 원래 상태로 복구 시도
                    showMessage("해제 실패", `❌ 도메인 해제 중 오류가 발생했습니다.<br>${data.message || '서버 응답 오류'}`, false);
                    updateSecurityStatusUI('해제 실패 (HTTPS 유지 시도)', 'status-value-success');
                }
            } catch (error) {
                // 통신 오류 시: 상태를 '통신 오류'로 업데이트 후 원래 상태로 복구 시도
                showMessage("통신 오류", `❌ 서버와 통신 중 오류 발생: ${error.message}`, false);
                updateSecurityStatusUI('통신 오류 (HTTPS 유지 시도)', 'status-value-success');
            }
        });

        console.log("도메인 및 보안 관리 페이지 로드됨.");
    });
</script>
{% endblock %}